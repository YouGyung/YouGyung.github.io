{"componentChunkName":"component---src-templates-blog-post-js","path":"/3/","result":{"data":{"site":{"siteMetadata":{"title":"yougyung.github.io"}},"markdownRemark":{"id":"03226e8a-89a0-55a5-b66e-a0e49d17f0a7","excerpt":"프로그래머스 데브코스를 진행하면서 로토 강사님의 FE…","html":"<p>프로그래머스 데브코스를 진행하면서 로토 강사님의 FE렌더링 강의를 듣고, 모르는 개념도 존재하고 중간에 이해가 명확하지 않은 부분이 존재해 렌더링에 대한 이해가 부족하다고 느꼈어요. 강사님의 강의를 토대로 제 공부를 더해 랜더링 흐름에 대해서 정리하고 개인적인 생각을 덧붙인 글입니다.</p>\n<h3>100% Static HTML</h3>\n<p>FE렌더링을 저 끝까지 돌이켜보면, 처음에는 완전 정적인 HTML파일만 제공했다고 해요.</p>\n<p>1990년대 후반 경에 서버에서 완전 고정된 정적 HTML파일만 내려주고 URL경로가 파일 경로이던 시절에 해당합니다.</p>\n<h3>Server Side Template</h3>\n<p>조금지나서 JSP, jango 등 서버사이드에서 특정한 template 문법으로 마크업을 생성해주는 언어가 등장합니다. 이전의 완전 정적인 HTML을 제공하는 것에서 벗어나, server application에서 동적으로 html을 생성해서 내려주는 방식으로 진화하게 된 것이죠.</p>\n<p>[클라이언트 → web server → web application server → DB] 구조로 되어있어서, 정적 컨텐츠는 web server가 web application server를 거치지 않고 바로 제공하고, 동적 컨텐츠는 web server가 요청을 web application server로 보내 생성한 html를 전달받아 내려주는 방식으로 정적/동적 컨텐츠를 제공해요. 인터렉션이 발생하는 경우에는 javascript를 클라이언트에서 별도로 실행하는 방식으로 처리했습니다.</p>\n<p>web application server에서 정적/동적 컨텐츠를 모두 처리하면 되는 것이 아닌가?라는 의문이 들었는데, WAS는 DB조회 및 로직 처리가 중심 기능이더라고요. 정적 컨텐츠는 web server에서 처리하는 것이 서버 부하를 방지할 수 있게 되는 것이죠.</p>\n<p>더불어 이 시기에 많이 사용되었던 것이 Asynchronous JavaScript and XML(AJAX)인데요. JavaScript와 XMLHttpRequest객체를 사용해서 클라이언트와 서버가 비동기적으로 통신하는 방식입니다. 당시 동적 웹페이지를 만들기 위해서 사용한 방법으로, 페이지 전체를 리렌더링하는 것이 아니라 필요한 부분에 한해서 렌더링이 가능해서 AJAX를 통해서 데이터를 불러와서 클라이언트단에서 추가로 렌더링하는 방식을 많이 사용했다고 해요.</p>\n<p>저는 사실 경험해본적 없는 시절인데, 멘토님에게 전해듣기로는 기능 구현에따라서 같은 뷰 로직이 server side에서와 client side에서 모두 구현이 되어야 한다는 특징이 몹시 번거로우셨다고 해요.</p>\n<p>첫 렌더링은 JSP로 그렸는데, API를 호출해서 동적인 움직임이 필요한 경우에는 js에서 마크업의 변화가 발생해야하고 해당 동일한 뷰를 서버와 클라이언트단에서 그려야하는데, 누락이 발생하거나 수정을 한쪽만 하는 등의 문제가 많이 발생했다고 해요. 렌더링 시점이 뒤섞이면서 복잡한 인터렉션이 발생하는 경우에는 그 난이도가 갈수록 높아지는 것이죠.</p>\n<h3>SSR</h3>\n<p>개발 난이도 뿐만아니라 server side tamplate방식은 UX에도 방해가 되었는데요. MPA는 화면의 이동이 발생할때마다 html,css,js를 서버에서 새로 받아와 새롭게 그리므로 화면깜빡임이 발생할 수 밖에 없는데 AJAX를 통해서 동적으로 데이터 fetch + hashbang을 통한 페이지의 이동 없이 URL변경이 이뤄지면서 페이지 전환 방식의 변화가 발생합니다.</p>\n<p><a href=\"https://yougyung.github.io/#hello\">https://yougyung.github.io/#hello</a> 에서 해시(#)뱅(!)의 뒤에 붙는 부분은 fragment identifier라고 부릅니다. hashbang기법을 통해 변경된 URL을 제공할 수 있고, AJAX를 통한 데이터 노출이 가능해져서 화면의 깜빡거림 없이 전환과 로딩을 통한 UX개선을 만들어낸 거죠. 하지만 해당 hashbang은 크롤러가 해쉬 뱅이 적용된 사이트의 콘텐츠를 불러오지 못하는 SEO문제가 존재했어요.</p>\n<p>하지만 해당 SEO문제도 PJAX가 등장하면서 해결됩니다. 이후에 historyAPI가 등장함을 통해 pushState와 Ajax를 결합한 것이 PJAX인데,historyAPI의 pushState, replaceState으로 페이지 이동 없는 브라우저의 주소 변경이 가능해지고, 첫 페이지 접속은 서버에서 내려주는 HTML을 렌더링하고이후 페이지 전환을 의도하는 경우에는 브라우저가 실제 페이지 전환없이 ajax와 pushState 서버로부터 렌더링할 HTML을 불러와서 교체하며 MPA와 1:1대응이 가능해집니다.즉 MPA+ajax+pushState가 전통적인 MPA 구조를 유지하면서도 SPA의 이점을 활용하며 서버사이드 렌더링을 실현하는 것이죠.</p>\n<h3>CSR</h3>\n<p>브라우저 및 javascript의 발전으로 그냥 렌더링을 client에서 전부하자는 시도가 드러났어요. 웹 어플리케이션은 HTML, CSS, JS만 가지고 있어서 뷰 로직은 전부 client에 존재하고, server에서는 API형태로 데이터만 내려주는 형태가 만들어진거죠.</p>\n<p>서버상에서 실행하는 코드 없이 브라우저에서 JS를 실행해서 돌아가는게 대부분이므로 배포를 쉽고 빠르게 할 수 있으며 <strong>무엇보다 별도의 서버 관리 없이</strong> 운영이 가능해진다는게 특징이었어요. 서버가 존재하지 않으므로 URL도 client에서 처리하는 single page applicaiton의 성격을 갖게됩니다.</p>\n<p>CSR의 특징에서 비롯되는 단점도 존재합니다. SPA는 어느페이지를 접속해도 매번 같은 index.html을 내려주므로 meta:og 태그 관련 문제가 발생되며 SEO관점에서 불리하게 작용해요. 더불어 fe가 복잡해지면서 번들 사이즈가 점점 커지고, 이 부분이 lighthouse의 성능 점수가 낮게 나오는 요소로 작용해요.</p>\n<h1>다시 SSR</h1>\n<p>기존 ssr의 문제점으로 제고되는 ss,cs에서 각각 렌더링을 위한 코드를 만들어야한다는 문제가 두드러졌음. 노드 js의 발전으로 이전과는 다른 점이 서버와 클라이언트가 같은 언어를 사용할 수 있다는 점이 다시 SSR로 발전하는 흐름으로 이끈 것 isomorphic(Universal)방식 (같은 코드로 server및 client에서 동일하게 실행되는 환경)을 통해 SSR 구축시에는 같은 언어로 동작하는 node.js를 서버로 사용하는 경우가 많음</p>\n<p>이 경우에도 문제는 발생하는데 서버와 클라이언트에서 같은 코드로 동작가능하게 만들어야하므로, Server-side에서는 사용할 수 없는 window객체를 사용하는 경우에 이를 예외처리해줘야하는 제약이 존재함.</p>\n<p>ssr문제를 isomorphic로 제공하는것이 nextjs프레임워크</p>\n<p>nodejs의 발전으로 client와 server가 같은 언어를 쓸 수 있게 되면서 다시 렌더링의 책임을 server로 일부 돌리는 움직임이 발생. 중요한 것은 python, java등의 언어로 하던 이전의 방식과는 근본적으로 다른것이 client와 server가 각각의 언어로 뷰로직을 구현하는 것이 아닌, 뷰 로직은 같은 언어로 공유한다는 차원이 다른 것이며, 의미론적으로 server template기반의 렌더링과 비슷</p>\n<ul>\n<li>CSR과는 다르게, serverless가 아니게 되므로, server 관리 책임이 생김(트래픽이 몰리면 서버를 늘려야하고, 없으면 줄여야함)</li>\n<li>스케일 업 다운 등의 과정을 거치므로 배포시간이 더 오래걸리고 세팅이 복잡하다는 문제가있음.</li>\n</ul>\n<h1>그리고..</h1>\n<p>SSR의 경우에 렌더링 결과를 redis에 캐시해서 제공하는 식으로 최적화하던데, 모든 경우의수를 html파일로 만들면? → SSG</p>\n<ul>\n<li>동적 페이지를 포함해서 사이트의 모든 페이지를 미리 정적으로 생성함</li>\n<li>모든 동적인 케이스에 따라서 사이트를 만들기때문에 server가 필요없어지며 meta tag문제도 해결가능</li>\n<li>렌더링 한 결과물을 제공하므로 js실행시간도 단축</li>\n<li>🌟 이미 생성된 정적인 페이지를 내려주므로 CDN을 통해 제공할 수 있어서 속도에서 큰 이득 🌟</li>\n<li>하지만, 동적으로 렌더링해야하는 컨텐츠가 많으 경우 빌드시간이 컨텐츠 갯수에 비례해서 증가하고 배포된 이후에 컨텐츠의 내용이 바뀌면, 변경된 내용을 반영하기 위해서 다시 빌드 및 배포를 진행해야하므로 개인 블로그 및 라이브러리 문서 페이지수준으로 사용됨.</li>\n</ul>\n<p>Distributed persistent rendering</p>\n<ul>\n<li>SSG의 단점을 보완하기 위한 방법으로 정적생성을 한다는 점이 동일하지만, 일부 페이지만 정적으로 생성하고 비교적으로 중요하지않은 페이지는 최초접근 시렌더링하고 그 결과를 정적으로 만들어버리는 개념으로 모든 페이지를 미리빌드할필요가없어 빌드시간을 줄일수있음\n<ul>\n<li>서버가 필요하긴하지만, SSR보다는 서버 의존도가 낮음</li>\n<li>해당개념을 nextjs에서 ISR(incremental static regeneration)이라는 개념으로 지원</li>\n</ul>\n</li>\n</ul>\n<p>ISR</p>\n<ul>\n<li>정적으로 생성되는 페이지에 필요시 revalidate라는 값으로 유효시간을 설정해서 유효시간 이전에 들어온 요청에 대해서는 정적인 response을 보내고, 이후에 들어온 요청에 대해서는 서버를 띄워서 다시 만들어 보내는 것으로 처리\n<ul>\n<li>컨텐츠의 변경이 실시간으로 반영되지는 않지만, 다시 빌드 및 배포해야한다는 부담이 사라지고, 최신 버전에서는 revalidate를 강제할 수 있는 기능이 추가됨(vercel기준)</li>\n</ul>\n</li>\n</ul>","frontmatter":{"date":"2024.07.28","title":"FE 렌더링 흐름 이해하기 그리고 내가 프로젝트를 할 때 rendering방식을 결정하는 기준","description":"프로그래머스 데브코스를 진행하면서 로토 강사님의 FE렌더링 강의를 듣고, 모르는 개념도 존재하고 중간에 이해가 명확하지 않은 부분이 존재해 렌더링에 대한 이해가 부족하다고 느꼈어요. 강사님의 강의를 토대로 제 공부를 더해 랜더링 흐름에 대해서 정리하고 개인적인 생각을 덧붙인 글입니다.","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/dee5283032654f4a778e83a6dc10ea09/f3fab/3.png","srcSet":"/static/dee5283032654f4a778e83a6dc10ea09/bcdba/3.png 200w,\n/static/dee5283032654f4a778e83a6dc10ea09/08292/3.png 400w,\n/static/dee5283032654f4a778e83a6dc10ea09/f3fab/3.png 800w","sizes":"(min-width: 800px) 800px, 100vw"},"sources":[{"srcSet":"/static/dee5283032654f4a778e83a6dc10ea09/8a265/3.webp 200w,\n/static/dee5283032654f4a778e83a6dc10ea09/268cf/3.webp 400w,\n/static/dee5283032654f4a778e83a6dc10ea09/8f181/3.webp 800w","type":"image/webp","sizes":"(min-width: 800px) 800px, 100vw"}]},"width":800,"height":391}}}}},"previous":{"fields":{"slug":"/hello-world/"},"frontmatter":{"title":"tailwind theme 동적 할당을 통한 커스텀 애니메이션 구현하기"}},"next":null},"pageContext":{"id":"03226e8a-89a0-55a5-b66e-a0e49d17f0a7","previousPostId":"34007725-73a0-5275-b2ca-32619df50e72","nextPostId":null}},"staticQueryHashes":["2841359383"],"slicesMap":{}}